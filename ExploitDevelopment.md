#### Stack Operational Terms
  - **Heap** – memory that can be allocated and deallocated as needed.
  - **Stack** – a contiguous section of memory used for passing arguments to other functions and general housekeeping.
  - **Registers** – Storage elements as close as possible to the central processing unit (CPU). There are many uses and types of registers, but in simple terms, general purpose registers can be used for whatever function is desired, that is fetching the contents of something from memory and placing it in the register for some computation/comparison, or special purpose registers such as the Instruction Pointer (IP), or Stack Pointer (SP) which are discussed below.
  - **Instruction Pointer (IP)** – (AKA Program Counter (PC) contains the address of next instruction to be executed. When the instruction is executed, it increments to the next instruction unless the instruction transfers control to another location by replacing the contents of the IP with the address of the next command to be executed through the process of jumping, calling, or returning. 
  - **Stack Pointer (SP)** – Contains the address of the next available space on the stack. The x86 architecture utilizes a top-down stack. When an item is saved on the stack (using a push command), it will be placed in the location addressed by the SP, after which, the SP will be decremented. When an item is fetched from the stack (using a pop instruction), the SP is decremented and then the item is retrieved from the address pointed to by the SP.
  - **Base Pointer (BP)** – The base of the stack. Used to ensure that items placed on the stack can be referenced using an offset relative to the BP. Because each function is provided a portion of the stack, it can be used to ensure that the function does not address items outside the bounds of their area on the stack. When there is nothing on the stack the BP will equal SP.
  - **Function** - Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient. Functions can be written within the program or can exist outside of the main program through the processing of linking (accessing code outside the main program). When a function allocates space for variables, those variables are placed on the stack, so when the function completes and returns back to the calling function, access to those.
  - **Shellcode** – The code that is executed once an exploit successfully takes advantage of a vulnerability. Shellcode often provides a shell to the actor, but it doesn’t have to. Whatever the intended effect is, is written in the shellcode.
  - The terms IP, BP, SP, etc are used in this document. Register names are different depending on the x86 architecture. IP, BP, SP are used for 16 bit. The register names are prefixed with the letter E’ for extended which signifies 32 bit architecture. The letter R’ for register prefixes register names for a 64 bit architecture.
  
  #### Common types of memory exploits
    - Heap Overflow
    - Buffer Overflow 
      - The main goal of these exploits is to redirect flow of execution. This can be to injected shell code or things that are already running in memory.
    - Buffer Overflow Defenses
      - Non executable stack (NX)
      - Address Space Layout Randomization (ASLR)
      - Data Execution Prevention (DEP)
      - Stack Canaries 
        - piece of code watches over the rest of the code, something about will not execute without a password
      - Position Independent Executable (PIE) 
        - randomizes order of code that bytes are read
      
exploit development process: 
  - Step1: run the program
  - Step2: see if you can buffer overflow (AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA)
    - "Segmentation fault (core dumped)" means can dump it
  - Step3: use gdb 
    - `gdb func`
    - `pdisass main` - dissasemblying main function
      - greens in peda are functions being called
      - `pdisass getuserinput` 
        - disassemblying function getuserinput that was called by main
    - xxx
    - xxx
    - `env - gdb func` - fresh gdb
    - show env 
      - `unset env <EnvironmentVar>`
    - run
    - overflow by AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa
    - `info proc map`
    - grab start addr of 1 below heap and end addr of 1 above stack
      - `find /b 0xf7de0000, 0xf7ffe000, 0xff, oxe4`
      - grab a handful of the jump esps
      - put them in script in a multiline comment
        - break it up into bytes (spaces between 2 characters)
      -  put bytes in reverse in variable
    -  Linux x86 exec is an important exploit or somethin
      - `msfvenom -p linux/x86/exec CMD="whoami" -b '\x00' -f python` 
        - copy the shell code (buf += stuff)
---
`proxychains scp -P 2222 exploi.py comrade@192.168.28.111:/home/comrade`

`proxychains scp -P 2222 comrade@192.168.28.111:/.hidden/inventory.exe .`
  
